#!/usr/bin/env python3

import json
import os
import re

from flowcraft_utils.flowcraft_base import get_logger, MainWrapper

"""
Purpose
-------

This module is intended to process the output generated by
 kraken to generate a file parsable as to generate a report in json format.


Expected input
--------------

The following variables are expected whether using NextFlow or the
:py:func:`main` executor.

- ``kraken_report``: kraken output.

Generated output
----------------
- ``kraken.tsv``: tsv with kraken results

Code documentation
------------------

"""


__version__ = "1.0.1"
__build__ = "18.10.2018"
__template__ = "kraken_fa-nf"

logger = get_logger(__file__)

if __file__.endswith(".command.sh"):
    FILE = '$kraken_report'
    SAMPLE_ID = '$sample_id'
    logger.debug("Running {} with parameters:".format(
        os.path.basename(__file__)))
    logger.debug("FILE: {}".format(FILE))
    logger.debug("SAMPLE_ID: {}".format(SAMPLE_ID))



def read_kraken_report(kraken_report):
    """
    Read Kraken report into a variable
    Parameters
    ----------
    kraken_report : str
        Path to Kraken report (results) file
    Returns
    -------
    kraken_results : str
        String with Kraken report
    """
    kraken_results = None

    with open(kraken_report, 'rt') as reader:
        kraken_results = reader.read()

    return kraken_results

def parse_kraken_results(kraken_results):
    """
    Parse the Kraken report
    Parameters
    ----------
    kraken_results : str
        String with Kraken report. If using a file to store the report, save the file into a variable
    Returns
    -------
    tree_data : dict

    """

    tree_data = {}

    classified = 0
    D = ''
    D_level = 0
    P = ''
    P_level = 0
    C = ''
    C_level = 0
    O = ''
    O_level = 0
    F = ''
    F_level = 0
    G = ''
    G_level = 0
    S = ''

    for line in kraken_results.splitlines():
        if len(line) > 0:
            fields = line.split('\t')
            if fields[3].strip() == 'U':
                unclassified = float(fields[0].strip())
                tree_data["unclassified"] = unclassified

            elif fields[5].strip() == 'root':
                classified = float(fields[0].strip())
                tree_data["classified"] = {classified: {}}

            elif fields[3].strip() == 'D':
                D = fields[5].strip()
                D_level = float(fields[0].strip())
                tree_data["classified"][classified][D] = {D_level: {}}

            elif fields[3].strip() == 'P':
                P = fields[5].strip()
                P_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P] = {P_level: {}}


            elif fields[3].strip() == 'C':
                C = fields[5].strip()
                C_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P][P_level][C] = {C_level: {}}

            elif fields[3].strip() == 'O':
                O = fields[5].strip()
                O_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P][P_level][C][C_level][O] = {O_level: {}}
        
            elif fields[3].strip() == 'F':
                F = fields[5].strip()
                F_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P][P_level][C][C_level][O][O_level][F] = {F_level: {}}

            elif fields[3].strip() == 'G':
                G = fields[5].strip()
                G_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P][P_level][C][C_level][O][O_level][F][F_level][G] = {G_level: {}}

            elif fields[3].strip() == 'S':
                S = fields[5].strip()
                S_level = float(fields[0].strip())
                tree_data["classified"][classified][D][D_level][P][P_level][C][C_level][O][O_level][F][F_level][G][G_level][S] = S_level

                


    print(tree_data.items())

    return tree_data


def write_tsv(sample_id, results_parsed):


    dict_keys = {}
    """
    dict: Used to count the total number of results for each key level
    """

    levels = []
    """
    list: List of the resulting levels, with values, keys, and children
    """

    for key, value in results_parsed.items():

        level_to_use = key[0]



def main(file_path, sample_id):

    kraken_results = read_kraken_report(file_path)
    results_parsed = parse_kraken_results(kraken_results)

    write_tsv(sample_id, results_parsed)


if __name__ == "__main__":
    main(FILE, SAMPLE_ID)
