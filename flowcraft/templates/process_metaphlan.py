#!/usr/bin/env python3

import json
import os
import re

from flowcraft_utils.flowcraft_base import get_logger, MainWrapper

"""
Purpose
-------

This module is intended to process the output generated by
 metaphlan to generate a report in json format.


Expected input
--------------

The following variables are expected whether using NextFlow or the
:py:func:`main` executor.

- ``metaphlan``: metaphlan output.

Generated output
----------------
- ``.report.jason``: Data structure for the report

Code documentation
------------------

"""

__version__ = "1.0.1"
__build__ = "05.10.2018"
__template__ = "metaphlan_fa-nf"

logger = get_logger(__file__)

if __file__.endswith(".command.sh"):
    FILE = '$metaphlan'
    SAMPLE_ID = '$sample_id'
    logger.debug("Running {} with parameters:".format(
        os.path.basename(__file__)))
    logger.debug("FILE: {}".format(FILE))
    logger.debug("SAMPLE_ID: {}".format(SAMPLE_ID))




def main(file_path, sample_id):
    parsed_file = parse_file(file_path)
    get_results(parsed_file,sample_id)


def parse_file(file_path):
    """Parse classifications tab from krona or kraken and returns the results
    without duplicated statements

    :param file_path:
    :return: dict
    """

    classifier_match = {}
    """
    dict: Match between line keys and their values. Used to merge similar 
    results
    """

    pattern = re.compile(r'\\s+')

    # Remove spaces and add tabs since results are not \t separated by default.
    # Adds keys and values to the classifiers_match dictionary
    with open(file_path, 'r') as file_parsed:
        for line in file_parsed:
            new_line = re.sub(pattern, "\\t", line.strip()).split("\\t")
            classifier_match[",".join(new_line)] = new_line

        classifier_keys = list(classifier_match.keys())
        to_remove = []

        # Check entries that are contained in others and mark them for removal
        for key1 in classifier_keys:
            for key2 in classifier_keys:
                if key1 in key2 and key1 != key2:
                    to_remove.append(key1)

        # Remove marked entries
        for remove in to_remove:
            del classifier_match[remove]

        new_file_parsed = []

        for key in classifier_match:
            new_file_parsed.append(classifier_match[key])

    return new_file_parsed


def get_results(parsed_file, sample_id):
    """crete json tree data structure with kraken or krona classifications.
    Writes a results file

    :param parsed_file:
    """

    # Parse kraken or krona CSV results file
    dict_keys = {}
    """
    dict: Used to count the total number of results for each key level
    """

    levels = []
    """
    list: List of the resulting levels, with values, keys, and children
    """

    for line in parsed_file:
        value = 0
        # Count total number of results for each level. If line only has a
        # value, it is classifier as Unclassified
        for index, level in enumerate(line):
            if len(line) == 1:
                level_to_use = "Unclassified"
                value = level
            else:
                level_to_use = level

            if index > 0 or len(line) == 1:
                if level_to_use not in dict_keys:
                    dict_keys[level_to_use] = float(value)
                else:
                    dict_keys[level_to_use] += float(value)
            else:
                value = level_to_use

    for line in parsed_file:
        current_level = {}
        # Reads the array reversed and creates the dictionary tree of
        # classification of children. Last element has and empty object has
        # children.
        for index, level in enumerate(line[::-1]):
            try:
                current_level = {
                    "key": level,
                    "value": dict_keys[level],
                    "children": current_level
                }
            except KeyError:
                print("Value not in dictionary")

        levels.append(current_level)

    with open(".report.json", "w") as k:
        k.write('{"plotData":[{"sample":"' + sample_id + '", "data": { "kronaPlot":')
        k.write(json.dumps(levels))
        k.write('}}]}')

if __name__ == "__main__":
    main(FILE, SAMPLE_ID)

