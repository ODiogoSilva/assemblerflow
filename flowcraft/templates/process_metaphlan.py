#!/usr/bin/env python3

import json
import csv
import os

from flowcraft_utils.flowcraft_base import get_logger, MainWrapper

"""
Purpose
-------

This module is intended to process the output generated by
 metaphlan to generate a report in json format.


Expected input
--------------

The following variables are expected whether using NextFlow or the
:py:func:`main` executor.

- ``metaphlan``: metaphlan output.

Generated output
----------------
- ``.report.jason``: Data structure for the report

Code documentation
------------------

"""

__version__ = "1.0.1"
__build__ = "05.10.2018"
__template__ = "metaphlan_fa-nf"

logger = get_logger(__file__)

if __file__.endswith(".command.sh"):
    FILE = '$metaphlan'
    logger.debug("Running {} with parameters:".format(
        os.path.basename(__file__)))
    logger.debug("FILE: {}".format(FILE))


def main(file_path):


    # Parse krona TSV results file
    file_parsed = list(csv.reader(open(file_path, 'r'), delimiter='\t'))

    dict_keys = {}
    """
    dict: Used to count the total number of results for each key level
    """
    levels = []
    """
    list: List of the resulting levels, with values, keys, and children
    """

    for line in file_parsed:
        value = 0
        # Count total number of results for each level. If line only has a
        # value, it is classifier as Unclassified
        for index, level in enumerate(line):
            if len(line) == 1:
                level_to_use = "Unclassified"
                value = level
            else:
                level_to_use = level

            if index > 0 or len(line) == 1:
                if level_to_use not in dict_keys:
                    dict_keys[level_to_use] = float(value)
                else:
                    dict_keys[level_to_use] += float(value)
            else:
                value = level_to_use

    for line in file_parsed:
        current_level = {}
        # Reads the array reversed and creates the dictionary tree of
        # classification of children. Last element has and empty object has
        # children.
        for index, level in enumerate(line[::-1]):
            try:
                current_level = {
                    "key": level,
                    "value": dict_keys[level],
                    "children": current_level
                }
            except KeyError:
                print("Value not in dictionary")

        levels.append(current_level)

    with open("parsed_krona.txt", "w") as k:
        k.write(json.dumps(levels))


if __name__ == "__main__":
    main(FILE)

